

# Система координат

Пользователю рекомендуется сначала прочитать [это руководство] (https://www.freecadweb.org/wiki/Assembly_Basic_Tutorial), чтобы получить некоторое представление о новой концепции _локальных систем координат_. Учебное пособие предназначено для исходной незаконченной верстака Assembly, но также дает довольно полный обзор того, что предоставляет Assembly3. Контейнеры `Part` или` Product`, упомянутые в учебнике, эквивалентны контейнеру `Assembly` в Assembly3, который, конечно, можно рассматривать как _part_ и добавлять в другие сборки. Есть одна вещь, с которой я не согласен с этим уроком. Концепция _глобальной системы координат_ по-прежнему полезна и необходима для взаимодействия с объектами из других унаследованных (т. Е. Не локально-поддерживающих CS) инструментальных средств. Давайте просто определим _глобальную систему координат_ как систему координат трехмерного вида, другими словами,место, где вы фактически видите объект в 3D-виде, или координаты, отображаемые в строке состояния, когда вы наводите указатель мыши на какой-либо объект.

В вышестоящем FreeCAD существует контейнер `App :: Part`, который представляет собой объект группового типа, определяющий локальную систему координат. Отличие от контейнера Assembly3 заключается в том, что один объект может быть добавлен в один и только один контейнер `App :: Part`. Контейнер-владелец может быть добавлен к другому контейнеру `App :: Part`, но все же должен подчиняться правилу одного прямого родительского контейнера. Причина этого заключается в том, что когда любой объект добавляется в `App :: Part`, он физически удаляется из исходной родительской системы координат и добавляется в систему координат владельца` App :: Part`, поэтому объект не может появиться в более одной системы координат. Под словом «физически удалено» я подразумеваю, что данные трехмерного визуального представления физически перемещаются в другую систему координат внутри графа трехмерной сцены (см. [Здесь] (https: //www.freecadweb.org / wiki / Scenegraph) для получения более подробной информации).

Контейнер Assembly3 не имеет такого ограничения. При добавлении в контейнер Assembly3 визуальные данные объекта просто повторно используются и вставляются несколько раз в граф сцены, что означает, что объект фактически существует одновременно в нескольких системах координат. Это имеет несколько неожиданный побочный эффект. Когда объект добавляется в сборку с некоторым размещением, объект, похоже, прыгает в новое место (Обновление: есть новая функция для автоматической регулировки размещения при перетаскивании объекта в другую систему координат. Чтобы активировать ее, щелкните правой кнопкой мыши в любом месте дерева view и выберите `Параметры дерева -> Синхронизировать размещение`). Это ожидаемо, потому что объект входит в новую систему координат и, похоже, ведет себя так же, как `App :: Part`.Но на самом деле произошло то, что исходный объект внутри глобальной системы координат просто стал невидимым перед добавлением в контейнер сборки. Вы можете проверить это, вручную переключив свойство `Visibility`, чтобы показать объект в его исходном положении. Свойство Visibility каждого объекта управляет его собственной видимостью только в глобальной системе координат. Каждый контейнер сборки имеет свойство VisibilityList для управления видимостью его дочерних элементов.

# Ссылка

Разветвленное ядро ​​FreeCAD представило новый тип объекта, называемый _Link_. Объект типа _Link_ (не путать со свойством _link_) часто не имеет собственных геометрических данных, а вместо этого связан с другими объектами (используя свойство link) для совместного использования геометрических данных. Его сопутствующий поставщик представления, Gui :: ViewProviderLink, связан с поставщиком представления связанного объекта для совместного использования визуальных данных. Это наиболее эффективный способ дублирования одного и того же объекта в разных местах с дополнительным масштабированием / зеркалом и переопределением материала. Ядро предоставляет расширение App :: LinkBaseExtension в качестве гибкого способа помочь пользователям расширить свой собственный объект до объекта типа ссылки. Расширение использует так называемый _ шаблон проектирования свойств_, что означает, что само расширение не определяет никаких свойств, но имеет набор заранее определенных заполнителей свойств.Расширение активирует часть своей функции в зависимости от того, какие свойства определены в объекте. Этот шаблон проектирования позволяет объекту выбирать собственные имена и типы свойств.

Ядро предоставляет два готовых к использованию объекта типа ссылки, `App :: Link` и` App :: LinkGroup`, которые предоставляют различные части функциональности `LinkBaseExtension`. App :: Link поддерживает ссылку на объект в том же или во внешнем документе и имеет встроенную поддержку массива (через свойство ElementCount) для эффективного дублирования одного и того же объекта. LinkGroup действует как объект группового типа с локальной системой координат. Он полагается на LinkBaseExtension и ViewProviderLink для обеспечения расширенных функций, таких как добавление внешнего дочернего объекта, добавление одного и того же объекта несколько раз и т. Д. Все контейнеры Assembly3 фактически настроены для LinkGroup.

# Элемент

«Элемент» - это новая концепция, представленная Assembly3. Он используется для минимизации ужасных последствий изменения топологического имени геометрии, а также привносит объектно-ориентированную концепцию из мира программирования в сборку САПР. «Элемент» можно рассматривать как объявление интерфейса подключения сборки-владельца, чтобы другая родительская сборка могла знать, какая часть этой сборки может быть соединена с другими.

Для системы, основанной на геометрических ограничениях, каждое ограничение определяет некоторую связь между геометрическими элементами некоторых пространственных объектов. Обычно ограничение относится к этим геометрическим элементам по их топологическим именам, таким как «Fusion001.Face1», «Cut002.Edge2» и т. Д. Проблема с этим простым подходом состоит в том, что топологическое имя непостоянно. Грани или кромки могут быть добавлены / удалены после изменения геометрической модели. Можно применить более сложный алгоритм, чтобы уменьшить количество смен топологических имен, но никогда не будет гарантии фиксированных топологических имен. Представьте простой, но все же крайний случай, когда пользователь просто хочет заменить всю дочернюю функцию, скажем, изменив тип какого-то винта. Эти две функции представляют собой совершенно разные геометрические объекты с разными топологическими именами.Пользователь должен вручную найти и изменить ссылки геометрических элементов на исходный дочерний элемент в нескольких ограничениях, которые могут существовать в нескольких иерархиях сборок в нескольких документах.

Решение, представленное Assembly3, заключается в использовании абстракции путем добавления нескольких уровней косвенных указаний к ссылкам на геометрию. Каждый контейнер `Assembly` имеет группу элементов, которая содержит список` Elements`, которые являются типом ссылки объекта, который ссылается на некоторый геометрический элемент некоторого дочернего элемента этой сборки. В случае, если функция также является `Assembly`, тогда` Element` в верхней иерархии вместо этого будет указывать на `Element` внутри сборки нижней иерархии. Таким образом, каждый элемент `Element` действует как абстракция, по отношению к которой геометрический элемент может использоваться другими родительскими сборками. Любое ограничение, включающее некоторую сборку, будет только косвенно связываться с элементом геометрии через элемент какой-либо дочерней сборки. Если топологическое имя геометрического элемента изменяется по какой-либо причине, пользователю нужно изменить только самое глубокое вложенное (т.е.ближайший к фактическому геометрическому объекту) Ссылка на ссылку `Element`, а также вся верхняя иерархия` Elements` и связанные ограничения остаются неизменными.

`Element` - это специализированный` App :: Link`, который ссылается на подобъект, используя `PropertyXLink`, который принимает ссылку` tuple (object, subname) `. Вдобавок, `Element` позволяет связываться по его метке вместо неизменного внутреннего имени объекта FreeCAD. `Element` специально позволяет дублировать свою метку (но по-прежнему обеспечивает уникальность среди своих братьев и сестер). Это позволяет пользователю определять взаимозаменяемые части с тем же набором элементов, что и интерфейс.

Давайте в качестве примера рассмотрим следующую иерархию сборок:

```
Assembly001
    |--Constraints001
    |       |--Constraint001
    |               |--ElementLink -> (Elements001, "$Element.")
    |               |--ElementLink001 -> (Parts001, "Assembly002.Elements002.$Element001.")
    |--Elements001
    |     |--Element -> (Parts001, "Cut.Face3")
    |--Parts001
          |--Cut
          |--Assembly002
                 |--Constraints002
                 |--Elements002
                 |      |--Element001 -> (Parts002, "Assembly003.Elements003.$Element002.")
                 |--Parts002
                       |--Assembly003
                                |--Constraints003
                                |--Elements003
                                |       |--Element002 -> (Parts003, "Fusion.Face1")
                                |--Parts003
                                       |--Fusion
```

Assembly001 имеет две дочерние функции: объект Cut и дочерний объект Assembly002, который, в свою очередь, имеет своего собственного дочернего элемента Assembly003. Assembly001 содержит ограничение Constraint001, которое определяет взаимосвязь двух его дочерних функций. Constraint001 относится к двум геометрическим элементам через две ссылки, ElementLink, которые указывают на ссылку второго уровня, Element. ElementLink001 указывает на Element001. И, поскольку первый дочерний элемент Cut не определен как сборка, его ссылка на геометрический элемент напрямую сохраняется внутри родительской группы элементов сборки. Однако `Element001` ссылается на нижнюю иерархию` Element002` в своей дочерней сборке, которая снова связана с `Element003` в своей дочерней сборке` Assembly003`. Обратите внимание на символ `$` внутри ссылок на подимя. Он отмечает, что следующий за ним текст является меткой, а не ссылкой на имя объекта.Если вы измените метку объекта, все `PropertyXLink` всех открытых документов, содержащих эту ссылку на метку, будут автоматически обновлены.

Основная идея заключается в том, что после того, как автор изменил сборку, будь то модификация геометрической модели или замена некоторого дочернего элемента. Ему необходимо проверить все ссылки на элементы внутри этой и только этой сборки и произвести надлежащую настройку, чтобы исправить любые нежелательные изменения. Другие сборки с элементами или ограничениями, относящимися к этой сборке, останутся такими же (хотя повторное вычисление по-прежнему требуется), даже если эти сборки находятся в разных документах или принадлежат другим авторам.

Допустим, мы изменили `Fusion`, а исходный` Fusion.Face1` теперь заменен на `Face10`. Все, что нам нужно сделать, это просто изменить `Element002` внутри той же сборки владельца` Fusion`. Все остальное остается прежним.  

Опять же, скажем, мы хотим заменить Assembly003 какой-нибудь другой сборкой. Теперь это немного сложно, потому что мы добавили `Aseembly003` непосредственно в` Assembly002`, вместо использования ссылки, которую можно изменять динамически. В ядре FreeCAD есть общая команда для упрощения этой задачи. Щелкните правой кнопкой мыши «Assembly003» в дереве и выберите «Действия со связью -> Заменить ссылкой». Assembly003 внутри Parts002 теперь будет заменено ссылкой на Assembly003. Каждая относительная ссылка, включающая `Parts002.Assembly003`, будет автоматически обновлена ​​до` Parts002.Link_Assembly003`. В нашем случае это будет Element001. Затем вы можете просто изменить ссылку, указав на другую сборку, содержащую объект элемента с той же меткой `Element001` (помните, что объект элемента допускает дублирование меток).Если вы по-прежнему настаиваете на добавлении новой сборки напрямую и избавляетесь от ссылки, вы можете использовать «Действия по связыванию -> разъединить», а затем удалить объект ссылки.

Может показаться устрашающим поддерживать все эти сложные иерархии элементов, но правда в том, что пользователю вовсе не обязательно вручную создавать какой-либо элемент. Просто выберите любые два элемента геометрии в 3D-виде, и вы можете создать ограничение, независимо от того, сколько уровней иерархий между ними. Все промежуточные элементы `Elements` и` ElementLinks` будут созданы автоматически. Хотя, ради возможности повторного использования, пользователю как автору сборки лучше явно создать `Element` в качестве интерфейсов и дать им собственные имена для легкой (повторной) сборки. Ознакомьтесь с учебным пособием [[this | Replacing-Part]] для демонстрации замены детали.

И последнее, но не менее важное: `Element`, а также` ElementLink` внутри ограничения используют новую базовую функцию `OnTopWhenSelected`, чтобы принудительно показать выделение соответствующего подэлемента геометрии (Face, Edge, Vertex ) при выборе, независимо от каких-либо затемняющих объектов. Свойство OnTopWhenSelected доступно для всех объектов представления, но по умолчанию имеет значение False, а Element и ElementLink делают его активным по умолчанию. Функция наверху упрощает пользователю проверку любых аномалий, связанных с изменением топологического имени.

# Выбор

В FreeCAD есть два типа выбора: выбор геометрического элемента щелчком в 3D-виде и выбор всего объекта щелчком в древовидной структуре. При использовании Assembly3 важно различать эти два типа выделения, потому что теперь существует множество объектов с одним геометрическим элементом. Пока вы привыкаете к ним, полезно открыть окно выбора (строка меню FreeCAD, `Вид -> Панели -> Вид выбора`). Вы выбираете геометрический элемент, щелкая любой невыделенный элемент (грань, ребро или вершину) в 3D-виде. Если вы щелкнете по уже выбранному элементу, выбор переместится на одну иерархию вверх. Например, для группы LinkGroup, показанной ниже,
```
LinkGroup
    |--LinkGroup001
    |       |--Fusion
    |       |--Cut
    |--Cut001 
```

Предположим, вы уже выбрали «Fusion.Face1». Если вы щелкнете по этой грани еще раз, выбор переместится на одну иерархию вверх и выделит весь объект `Fusion`. Если вы снова щелкните в любом месте внутри объекта «Fusion», выделение перейдет к «LinkGroup001», и вы увидите, что «Fusion» и «Cut» выделены. Если вы снова щелкните где-нибудь внутри LinkGroup001, то Cut001 тоже будет выделен, потому что вся LinkGroup выбрана. Щелкните еще раз в LinkGroup, выбор вернется к элементу геометрии, который вы только что щелкнули.  

В разветвленном представлении выбора FreeCAD появилась новая функция. Отметьте опцию «Включить список выбора» в окне выбора. Теперь вы можете выбрать любые перекрывающиеся геометрические элементы, которые пересекаются при щелчке мышью в окне выбора.

Возможно, вам будет полезно включить синхронизацию выбора в виде дерева (щелкните правой кнопкой мыши в древовидном представлении, выберите «Синхронизировать выбор»), чтобы дерево автоматически переместилось к объекту, который вы только что выбрали в 3D-виде. Когда вы выбираете изначально невыделенный объект в древовидной структуре, будет выбран весь объект. И если вы начинаете перетаскивать объект в древовидном представлении, вы перетаскиваете весь объект. Если вы выберете геометрический элемент в 3D-виде, его объект-владелец также будет выбран в древовидной структуре. Но если вы затем инициируете перетаскивание этого конкретного элемента объекта, вы фактически перетаскиваете выбранный элемент геометрии. Это важное различие, потому что некоторые контейнеры, такие как объект `Constraint`, принимают только удаление геометрического элемента и отказываются от удаления всего объекта.

* 2D / 3D эскиз

Использование эскиза в сборке - это метод, называемый _Skeleton Modeling_. Это тип подхода к проектированию сверху вниз, при котором вы рисуете эскизы скелетов (линий, дуг и т. Д.) Для определения критериев проектирования, а затем добавляете отдельные компоненты, которые ссылаются на эти критерии. Некоторые типы механических систем естественным образом моделируются в 2D, например, шарнирное соединение, которое может вращаться только в плоскости, в то время как другие должны моделироваться в 3D, например, шаровой шарнир.

FreeCAD уже имеет мощную рабочую среду _Sketcher_, но она ограничена созданием 2D-эскизов. Кроме того, средство эскиза больше ориентировано на моделирование геометрии, то есть создание оснований для выдавливания, кармана и т. Д. Объект эскиза хранит все элементы и ограничения внутри самого объекта. У него есть собственный редактор и решатель, что делает его, вероятно, самым сложным отдельным объектом во всем FreeCAD. Вместо того чтобы изменять объект эскиза в соответствии с потребностями сборки, Assembly3 решает изменить назначение некоторых объектов из рабочей среды _Draft_ без изменений. Верстак для черновиков, как я полагаю, изначально использовался для создания эскизов до того, как появился более специализированный эскиз.

На момент написания этой статьи Assembly3 поддерживает использование черновой проволоки и окружности / дуги для создания эскизов. Для обычных объектов, добавленных в сборочный контейнер как часть, размещение объекта используется в качестве ограничивающих параметров (см. [[Здесь | Ограничения и решатели]] для более подробной информации). Тяговая проволока обрабатывается особым образом. Вместо того, чтобы ограничивать размещение объекта, оно ограничивается координатами каждой отдельной точки. Окружность уклона по-прежнему ограничена ее размещением, как и другие объекты, но с дополнительным параметром для ее радиуса и дуги уклона, еще двумя параметрами для первого и последнего угла, которые определяют две его конечные точки. У Draft Wire есть много вариантов использования, не все из которых приемлемы для ограничения эскиза (например, LineLength). Допускаются только неразделенные провода без прикрепленного основания или инструмента.

Добавленные черновые объекты могут свободно перемещаться в трехмерном пространстве. Чтобы создать 2D-эскиз, вы можете добавить ограничение SketchPlane. Он принимает любую плоскую кромку или грань в качестве первого элемента для определения текущей плоскости эскиза. Любые элементы чернового объекта, участвующие в следующих ограничениях, будут неявно ограничены этой плоскостью. Вы также можете явно добавить элементы в ограничение `SketchPlane`. Чтобы сбросить текущую плоскость эскиза, то есть сделать следующие элементы уклона свободными в 3D, добавьте пустое ограничение SketchPlane. В одном сборочном контейнере может быть определено более одной плоскости эскиза.

Вы можете проверить [[this | Create-Skeleton-Sketch]] руководство, чтобы узнать больше

